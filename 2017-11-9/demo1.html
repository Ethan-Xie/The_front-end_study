<!doctype html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script type="text/javascript">
     //构造函数
     var F=function(){};
     var p=F.prototype;
     var c=p.constructor;
     console.log(c===F);//true
     F.prototype.constructor==F    //true

     var o=new F();
     o.constructor===F;//true;

     var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　return function(){
　　　　　　　　return this.name;
　　　　　　};
　　　　}
　　};
console.log((object.getNameFunc()()));

    //javascript定义类的三步法
    //complex.js，来表示复数的类
    //第一步，这个构造函数为它所创建的每个实例定义了实例r和i
    function Complex(real,imaginarty){
        if(isNaN(real) || isNaN(imaginarty))
            throw new TypeError;
        this.r=real;
        this.i=imaginarty;
    }
    //第二步；当前复数对象加上另外一个复数，并返回一个新的计算和值后的复数对象
    Complex.prototype.add=function(that){
        return new Complex(this.r+that.r,this.i+that.i);
    }

    //第三步：类字段和类方法  直接定义为构造函数的属性类
    //类字段， ，大写代表常量
    Complex.ZERO=new Complex(0,0);
    //类方法
    Complex.parse=function(s){
        try{
            var m=Complex._format.exec(s);//利用正则表达式进行匹配,方法在下面
            return new Complex(parseFloat(m[1]),parseFloat(m[2]));
        }catch (x){
            throw new TypeError("匹配出错");
        }
    }
    //"私有字段"，下划线代表它在类内部使用，不属于类的公有api的部分
    Complex._format=/^\{([^,],[^,])\}$/;
    //运行
    var o=new Complex(1,2);
    var o2=new Complex(1,2);
    console.log(o.add(o2));

    if(!Function.prototype.bind){
        Function.prototype.bind=function(o){

        }
    }
    
    </script>
    <title>无标题文档</title>
</head>
<body>


    
</body>
</html>